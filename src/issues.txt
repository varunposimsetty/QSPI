Awesome‚Äîthanks for sharing the latest version. You‚Äôre very close to a clean, minimal QSPI shifter. Below is a complete, **fix-me list** with what‚Äôs truly blocking vs. what‚Äôs just robustness/future-proofing. I‚Äôll stay high level (no code), but detailed enough that you can patch each item confidently.

---

# What‚Äôs already good

* Mode-0 timing intent (write on falling edge, read on rising edge).
* MOSI/MISO mapping: IO0 = MOSI (drive on writes), IO1 = MISO (sample on reads).
* `sclk` gating with `chip_select` (idles at CPOL, runs only when CS low).
* Freezing `operation`/`sel_mode` at transaction start (`*_sync` regs).
* Byte-aligned transfer with lane-aware stop conditions (0 / 1 / 3) for 1/2/4 lanes.

---

# üî¥ Critical must-fix (functional / synthesis blockers)

## 1) **Multiple drivers to the same regs across different clocked blocks**

* **What:** `enable_io` and `io_int` are assigned in **both** the write (negedge sclk) and read (posedge sclk) processes. Also, `data_buffer` gets written in the control block **and** in the read block (bit-wise).
* **Why it‚Äôs bad:** In SystemVerilog, a variable driven by `always_ff` must have exactly one procedural driver. Multiple clock domains driving the same reg is **unsynthesizable** and often a sim hazard.
* **Fix direction:** Give **one owner** to each reg:

  * One block should control `enable_io` for the entire transaction (e.g., set outputs enabled for writes, disabled for reads) and no other block touches it.
  * One block should own `io_int` (typically the write shifter only).
  * One block should own `data_buffer` (typically the read shifter OR the control block‚Äîbut not both). If you keep bit-wise captures in the read shifter, then the control block should **not** also assign to `data_buffer` except at transaction start/end (use a separate ‚Äúnext‚Äù capture buffer if you want to be extra clean).

## 2) **Reset edge mismatch in the READ block**

* **What:** The read process is sensitive to **posedge** of reset but tests `if (~nrst)`. That condition will never be true in that block.
* **Why it‚Äôs bad:** That block won‚Äôt actually reset; stale values can persist.
* **Fix direction:** Make the reset polarity and edge **consistent across all always_ff blocks**. Use the same reset edge/polarity everywhere, and test it consistently inside the if/else.

## 3) **Tri-state control during reads can remain ACTIVE from the last write**

* **What:** In read mode, you commented out the `enable_io` deassertion lines, so `enable_io` may retain the previous write‚Äôs drive pattern.
* **Why it‚Äôs bad:** You‚Äôll drive the bus while the ‚Äúflash/slave‚Äù also drives ‚Üí **contention**.
* **Fix direction:** Ensure **before** any read shifting starts, `enable_io` is cleared (master not driving). Only one block should set/clear it (see #1). Verify in waves that IO0..IO3 from the master are Z during reads.

## 4) **Race/phase alignment of `transmit_count` vs. sample/drive edges**

* **What:** `transmit_count` is updated on **posedge** of divided clock; write driving occurs on **negedge** of SCLK; read sampling on **posedge** of SCLK. Because posedge-update and posedge-sample happen at the **same edge**, read capture and counter update race. Also, the very first write edge can start one bit late due to a pre-decrement.
* **Why it‚Äôs bad:** Off-by-one errors and non-determinism between blocks on the same edge (simulators don‚Äôt guarantee order between always blocks).
* **Fix direction:** Align phases so the **counter updates on the opposite half-cycle** from the edge where you drive/sample:

  * For Mode-0: drive on falling edge, **decrement after that** (or sample on rising, then decrement; pick one consistent scheme).
  * The key is: ‚Äúpresent bit ‚Üí sample bit ‚Üí then decrement index‚Äù (not the other way around).

## 5) **Sensitivity list syntax in one block**

* **What:** One block uses `always_ff @(posedge sys_clk, negedge nrst)` with a comma in the list.
* **Why it‚Äôs bad:** Standard SV uses `or` in event lists. Some tools will reject the comma form for `always_ff`.
* **Fix direction:** Use the standard event list form consistently in all always_ff blocks.

---

# üü† Strongly recommended (robustness / correctness under stress)

## 6) **Synchronize `trigger_transmission` into the divided_clk domain**

* **What:** `trigger_transmission` likely originates in sys_clk domain but is consumed in the divided_clk domain.
* **Why it matters:** Even though divided_clk is derived from sys_clk, phase relationship isn‚Äôt guaranteed. You can hit metastability or multiple-cycle ambiguity.
* **Fix direction:** Add a simple synchronizer/edge detect into the divided clock domain, or require the upstream to present a clean pulse aligned to divided_clk. Your `transaction_done` gating helps, but proper sync removes flakiness.

## 7) **`chip_select` drop timing vs. last sample/drive**

* **What:** You deassert CS in the same cycle the counter reaches the stop condition.
* **Why it matters:** Since `sclk` is gated by `chip_select`, dropping CS exactly at the stop condition can cut off a half-cycle or create ambiguity on the last sample/drive event.
* **Fix direction:** Ensure you only raise CS **after** the final required edge has occurred (i.e., don‚Äôt truncate the final rising or falling edge that contains the last data/sample). A one-half-cycle/order guarantee is enough.

## 8) **Guard against invalid `sel_mode` (2‚Äôb11)**

* **What:** No default path for 2‚Äôb11.
* **Why it matters:** Defensive coding avoids ‚Äústicky‚Äù last-value bugs if an invalid mode slips through.
* **Fix direction:** Define a safe behavior (e.g., treat as single mode or ignore trigger) if an invalid mode is latched.

## 9) **Initialize all externally visible outputs on reset**

* **What:** `rd_data` isn‚Äôt explicitly cleared in your reset path.
* **Why it matters:** Simulation Xs and confusing first-read visibility.
* **Fix direction:** Clear `rd_data` (and any ‚Äúvalid‚Äù flag, if you add one) on reset.

## 10) **Clock divider duty and odd divisors**

* **What:** You toggle `divided_clk` when the count hits `CLOCK_DIVIDER-1`. Duty is 50% only if `CLOCK_DIVIDER` is constant and you start from zero. It‚Äôs fine now, but watch edge alignment if you later change it.
* **Fix direction:** Just be aware; your present divider is OK for now.

## 11) **Make ownership explicit for direction control**

* **What:** Direction switching (write‚Üíread) sometimes needs a ‚Äúturnaround‚Äù or dummy in real flash protocols.
* **Why it matters:** For your current shifter it‚Äôs OK, but once you talk to real NOR, you‚Äôll need a turnaround phase.
* **Fix direction:** Plan a tiny FSM step between write phase and read phase (even if it‚Äôs just holding Z for N dummy cycles).

---

# üü° Future-proof / style

## 12) **Counter widths (`int`)**

* **What:** `int` for `clk_count`/`transmit_count`.
* **Why:** Works in sim; synthesis will typically infer big flip-flops.
* **Fix direction:** When you care about resources, size them precisely (clog2 for dividers and width).

## 13) **CPHA/ADDR_WIDTH/DUMMY_CYCLES parameters unused**

* **What:** They‚Äôre listed but not applied.
* **Why:** Not wrong, just confusing to readers.
* **Fix direction:** Either wire them in later (CPHA edge alignment; address/dummy FSM stages) or drop until you implement flash opcodes.

## 14) **One-pulse vs. level trigger**

* **What:** You gate with `transaction_done`, so a stuck-high trigger will immediately start the next transaction when you return to IDLE.
* **Why:** Intentional if you want continuous mode; otherwise you may prefer a pulse requirement.
* **Fix direction:** Decide your handshake contract and document it.

---

# Quick self-tests to confirm fixes (no code, just what to look for)

1. **Contention check:** In READ transactions, confirm **all** master IO drivers are Z the whole time (IO0..IO3 tri-stated). If you ever see master-driven and slave-driven at once ‚Üí fix `enable_io` ownership (Issue #1/#3).

2. **Bit-order & off-by-one:** For Mode-0, watch one byte:

   * On **negedge** SCLK: MOSI must present the **current** bit (starting with MSB).
   * On **posedge** SCLK: MISO must be sampled into the **current** bit slot; **then** decrement the counter. If you see the first bit missing or duplicated, fix the counter phase (Issue #4).

3. **Final edge preserved:** On the last bit, confirm:

   * You still get the required sample/drive edge,
   * **then** CS rises and SCLK idles. If not, adjust CS timing (Issue #7).

4. **Reset consistency:** Assert/deassert reset mid-transaction in sim:

   * All state/outputs go to reset immediately,
   * After deassertion, the block doesn‚Äôt spontaneously restart unless trigger is (intentionally) held high. If it does, confirm your trigger policy (Issue #6/#14).

5. **Mode=11 safety:** Force `sel_mode=2‚Äôb11` in TB once, verify the DUT does something safe (Issue #8).

---

## Minimal plan to patch in order

1. Pick single ownership for `enable_io`, `io_int`, `data_buffer`.
2. Make reset edge/polarity consistent in **all** always_ff blocks.
3. Align `transmit_count` update to the opposite half-cycle of the bit action (no off-by-one).
4. Ensure master IO are Z during reads (no contention).
5. Adjust CS drop to occur **after** the last required edge.
6. (Optional now) sync `trigger_transmission` into divided_clk domain.
7. Reset `rd_data` and add invalid-mode guard.

Do these and your current design will be solid for byte-aligned Mode-0 SPI/Dual/Quad transfers, and you‚Äôll be ready to bolt on command/address/dummy phases for a real QSPI flash next.
