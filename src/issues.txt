Alright 👍 — let’s do a **full checklist** of the issues in your current QSPI\_Master so you can fix them one by one. I’ll keep it clear and structured:

---

## 🔹 Functional Issues

1. **Single-bit SPI mapping is flipped**

   * Correct convention:

     * IO0 = MOSI (master drives here on write).
     * IO1 = MISO (master samples here on read).
   * Your code currently drives IO1 and samples IO0 → needs swapping.

2. **enable\_io defaults are inconsistent**

   * You set `enable_io <= 4’b0011` at the top of the SPI branch, then overwrite with `0010` or `0001`.
   * Cleaner: decide per mode + per operation (write/read), not redundantly.

3. **temp\_io assignments in read mode**

   * In read paths, you still sometimes assign to `temp_io`. That’s unnecessary since the master isn’t driving.
   * Cleaner: in read mode → just leave temp\_io untouched, only capture IO\[] into data\_buffer.

---

## 🔹 Timing & Protocol Issues

4. **SCLK not CPOL/CPHA aware**

   * You assign `sclk = chip_select ? 1'b0 : divided_clk;` → this forces CPOL = 0 always.
   * CPOL/CPHA parameters exist but are unused.
   * For now that’s fine (basic working), but you’ll need to honor CPOL (idle level) and CPHA (shift/sample edge).

5. **Chip-select deasserts too early**

   * You deassert CS right after the last bit of a single byte.
   * In real flash protocols, CS must stay low across the entire transaction (command + address + data).
   * For “toy model” this is acceptable, but keep in mind for NOR flash you’ll need to restructure.

---

## 🔹 Data Handling Issues

6. **rd\_data not reset**

   * `rd_data` is only assigned at `finish` after a read.
   * Before first transaction it may hold X’s in simulation.
   * Not fatal, but initializing it avoids confusion.

7. **DATA\_WIDTH assumptions**

   * Dual mode increments `i` by 2, quad by 4.
   * If DATA\_WIDTH isn’t divisible by 2 or 4, you’ll misalign.
   * Either restrict DATA\_WIDTH to multiples of 2/4 or handle leftover bits.

---

## 🔹 Integration / Cleanliness Issues

8. **Trigger handling**

   * If `trigger_transmission` stays high for more than 1 cycle, you may re-enter transmit unexpectedly.
   * Safer: latch the trigger once, then ignore until transaction finishes.

9. **No “valid” flag**

   * You load `rd_data` at finish, but outside logic doesn’t know when it’s ready.
   * A `rd_valid` or `done` flag would make integration easier.

10. **Redundant reset code**

* You clear `data_buffer` twice in reset. Minor, but could be simplified.

---

## ✅ Suggested Fix Order

To make it manageable, fix in this order:

1. **SPI mapping** (IO0 = MOSI, IO1 = MISO).
2. **enable\_io patterns** (drive only what’s needed per mode).
3. **Remove temp\_io writes in read mode.**
4. **Initialize rd\_data on reset.**
5. **Restrict DATA\_WIDTH or handle leftovers.**
6. **Latch trigger\_transmission.**
7. (Optional, next phase) Add `rd_valid` / CPOL-CPHA / CS hold fixes.

---

👉 Do you want me to draft the **truth table for enable\_io & IO usage** across SPI/Dual/Quad + read/write, so you can implement fixes #1–#3 cleanly?
