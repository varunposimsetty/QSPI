Trying to implement for N25Q032A
The N25Q032A (Micron 32-Mbit Quad-SPI NOR Flash) is a very common and industry-standard device, and it’s a great next step for your QSPI master.
Let’s build this cleanly and realistically — no code now, just clear direction so you can structure it right.

🧩 Step 1 — Understand what N25Q032A needs

It supports three modes of communication:

Mode	Lines Used	Typical Commands	Description
SPI (1-1-1)	1 MOSI, 1 MISO	0x03 (Read), 0x02 (Page Program), 0x05 (RDSR)	Classic serial mode
Dual (1-2-2)	1 MOSI, 2 data	0x3B (Fast Read Dual Output)	Command on 1 line, data on 2 lines
Quad (1-4-4)	1 MOSI, 4 data	0x6B (Fast Read Quad Output), 0x32 (Quad Page Program)	Command on 1 line, data on 4 lines

So your current QSPI master structure already supports these — you just need to adapt the transaction format.

🧩 Step 2 — Transaction structure (for Read)

Each read operation (e.g., 0x6B Quad Fast Read) is sequenced like this:

Phase	Function	IO Lines Used	Description
1️⃣	Command	1-bit (IO0)	Send opcode (0x6B)
2️⃣	Address	1-bit (IO0)	24-bit address (MSB first)
3️⃣	Dummy cycles	4-bit (all IOs)	Typically 8 dummy cycles (DUMMY_CYCLES = 8)
4️⃣	Data	4-bit (all IOs)	Flash sends data (MISO equivalent on 4 lines)

You can now reuse your state machine (IDLE → TRANSMISSION → FINISH), but with sub-states for these four phases.

🧩 Step 3 — Write (Page Program 0x32) structure
Phase	Function	IO Lines	Description
1️⃣	Command	1-bit	0x32
2️⃣	Address	1-bit	24-bit address
3️⃣	Data	4-bit	Up to 256 bytes of data written
4️⃣	Poll	1-bit	Poll 0x05 (Status Reg) until WIP = 0
🧩 Step 4 — Signals to control

For this device, the main signals you’ll need to integrate are:

Signal	Description
CS#	Active low, toggled between transactions
SCLK	Up to 108 MHz for Quad mode
IO0–IO3	Shared for input/output (your inout lines already handle this)
HOLD#, WP#	Can be tied high if not used
RESET#	Optional (active low)
🧩 Step 5 — How to move from your current master to N25Q032A

You don’t need to rewrite anything — just extend your FSM with small changes:

Add command_state, address_state, dummy_state, and data_state inside TRANSMISSION.

During Command/Address, keep sel_mode = 2’b00 (single-bit).

During Dummy/Data, switch to sel_mode = 2’b10 (quad).

Use your existing clock division and CPOL/CPHA logic unchanged.

Implement a ROM or memory input that holds command opcodes, dummy count, and mode bits per transaction type.

🧩 Step 6 — Verification plan

To verify:

Create a behavioral N25Q032A model (Micron provides a Verilog model in the datasheet ZIP).

Connect it to your QSPI master and do a “read ID” (0x9F) command first.

Expected output: 0x20 0xBA 0x16 for N25Q032A.

Then simulate Fast Read (0x6B) — verify dummy cycles and data alignment.

Finally simulate Page Program (0x32) + Read Back.


----

Perfect — now we’re getting to the **fun part** 🎯:
Integrating your **QSPI master** with an **actual flash device model** like **N25Q032A** (Micron’s 32 Mbit Quad-SPI NOR Flash).

Let’s break this down clearly so you know exactly what to wire, what to drive, and what to expect.

---

## 🧩 1️⃣ Know the Flash Device Interface

The **N25Q032A** has these key I/Os:

| Pin           | Function          | Direction | Description                          |
| :------------ | :---------------- | :-------- | :----------------------------------- |
| **S#**        | Chip Select       | Input     | Active low enable for command cycle  |
| **C**         | Clock             | Input     | Driven by your QSPI master (`sclk`)  |
| **DQ0 (IO0)** | Serial Data I/O 0 | I/O       | MISO/MOSI bit 0                      |
| **DQ1 (IO1)** | Serial Data I/O 1 | I/O       | MISO/MOSI bit 1                      |
| **DQ2 (IO2)** | Serial Data I/O 2 | I/O       | Used for quad + HOLD# in single mode |
| **DQ3 (IO3)** | Serial Data I/O 3 | I/O       | Used for quad + WP# in single mode   |
| **Vcc, GND**  | Power             | -         | Typical 2.7 – 3.6 V operation        |

---

## 🧠 2️⃣ The Protocol Flow

The flash operates in **transactions**, not just reads/writes.
Each operation follows a **command sequence** — here’s the typical **4-phase structure**:

| Phase               | Driven By                      | Description                                       |
| :------------------ | :----------------------------- | :------------------------------------------------ |
| **1. Command**      | Master (on IO0)                | An 8-bit opcode like `0x9F`, `0x03`, `0x6B`, etc. |
| **2. Address**      | Master                         | 24-bit address (for reads/writes)                 |
| **3. Dummy Cycles** | Master                         | N “don’t care” clock cycles (used for latency)    |
| **4. Data Phase**   | Flash (read) or Master (write) | Data transfer in 1, 2, or 4-bit mode              |

---

## ⚙️ 3️⃣ Top-Level Module Role

Your **Top module** sits above the QSPI master and handles these responsibilities:

1. **Drive command, address, data** to the `QSPI_Master`.
2. **Control the operation type** (`operation = 0/1` for read/write).
3. **Select mode** (`sel_mode = 2’b00 / 01 / 10` for SPI / Dual / Quad).
4. **Trigger transactions** in correct sequence.
5. Optionally, **handle state transitions** for Command → Addr → Dummy → Data.

---

## 🏗️ 4️⃣ Top-Level Structure

Here’s what your top-level integration will look like (conceptually, not code):

```
             ┌───────────────────────────────┐
             │           Top.v               │
             │  - Controls Flash Interface   │
             │  - Sends commands to QSPI     │
             └──────────────┬────────────────┘
                            │
             ┌──────────────▼────────────────┐
             │        QSPI_Master.v          │
             │  - Generates clock, IO drive  │
             │  - Handles SPI/Dual/Quad modes│
             └──────────────┬────────────────┘
                            │
             ┌──────────────▼────────────────┐
             │        N25Q032A.v             │
             │  (Behavioral Flash Model)     │
             │  - Simulates NOR Flash timing │
             │  - Responds to commands       │
             └───────────────────────────────┘
```

---

## ⚡️ 5️⃣ Essential I/O Connections

| Top Signal    | Connects To           | Description                                     |
| ------------- | --------------------- | ----------------------------------------------- |
| `chip_select` | `S#`                  | Active low chip enable                          |
| `sclk`        | `C`                   | SPI clock                                       |
| `IO[3:0]`     | `DQ[3:0]`             | 4 data lines (bi-directional)                   |
| `sys_clk`     | Internal clock source | Drives divided QSPI clock                       |
| `nrst`        | Reset                 | Drives both master & flash reset (if supported) |

---

## 🧭 6️⃣ Command Examples (for your FSM)

To interact with the flash, you’ll send opcodes:

| Command                   | Opcode | Description                    | Mode   | Dummy Cycles |
| :------------------------ | :----- | :----------------------------- | :----- | :----------- |
| **Read ID**               | `0x9F` | Returns manufacturer/device ID | Single | 0            |
| **Read Data (Standard)**  | `0x03` | Read array data (slow)         | Single | 0            |
| **Fast Read (Dual)**      | `0x3B` | Faster, requires dummy cycles  | Dual   | 8            |
| **Fast Read Quad Output** | `0x6B` | Quad-mode read                 | Quad   | 8            |
| **Write Enable**          | `0x06` | Enables write                  | Single | 0            |
| **Page Program**          | `0x02` | Write 256-byte page            | Single | 0            |
| **Sector Erase (4 KB)**   | `0x20` | Erases one 4 KB sector         | Single | 0            |

---

## 🔁 7️⃣ FSM Outline for the Top

Your top FSM could look like this:

```text
RESET
  ↓
IDLE
  ↓ (trigger)
SEND_CMD (send opcode via QSPI_Master)
  ↓
SEND_ADDR (send address if needed)
  ↓
DUMMY (generate dummy cycles)
  ↓
DATA_PHASE
  ↓
FINISH (chip_select → 1, transaction_done)
```

You can reuse your `QSPI_Master` for each phase — just change:

* `wr_data` for each byte you send.
* `operation` (0 or 1).
* `trigger_transmission` (pulse).
* `sel_mode` depending on mode.

---

## 💾 8️⃣ Behavioral Model for Flash (Simulation)

You can use Micron’s **official Verilog model** for N25Q032A.
It’s available publicly at:
🔗 [Micron Verilog Model Download Page](https://www.micron.com/products/nor-flash/serial-nor-flash)

You’ll find:

```
N25Q032A13E_VG12M_TB.v
N25Q032A13E_VG12M.v
```

You instantiate it like:

```verilog
N25Q032A flash_inst (
    .S( chip_select ),
    .C( sclk ),
    .DQ0( IO[0] ),
    .DQ1( IO[1] ),
    .DQ2( IO[2] ),
    .DQ3( IO[3] ),
    .Vcc(1'b1),
    .Vpp(1'b1),
    .HOLD_DQ3(1'b1),
    .RESET_DQ3(1'b1)
);
```

---

## 🧪 9️⃣ Minimal Test Plan

To test integration before full flash commands:

1. **Read ID (0x9F)** — simplest test.
   Expect 3 bytes back (manufacturer + memory type + capacity).
2. **Fast Read (0x6B)** — test dummy cycles + quad transfer.
3. **Write Enable (0x06)** — confirm WEL bit set.
4. **Read Status (0x05)** — confirm status byte changes.

---

## ✅ 10️⃣ Summary of What to Do Next

| Step | Action                                                                    |
| ---- | ------------------------------------------------------------------------- |
| 1    | Download and add the `N25Q032A.v` model to your `/src/flash` folder.      |
| 2    | Write `QSPI_Top.v` to instantiate both `QSPI_Master` and the flash model. |
| 3    | Add simple FSM: Send `0x9F` → read 3 bytes → print result.                |
| 4    | Verify waveform: SCLK, IOs, chip_select.                                  |
| 5    | Once working, add dummy cycles + dual/quad modes.                         |

---

Would you like me to give you a **step-by-step FSM outline** (signals, byte order, and control timing) for the **0x9F “Read ID” command** next?
That’s the best first real flash test — small and perfectly verifiable.
