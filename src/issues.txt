Trying to implement for N25Q032A
The N25Q032A (Micron 32-Mbit Quad-SPI NOR Flash) is a very common and industry-standard device, and itâ€™s a great next step for your QSPI master.
Letâ€™s build this cleanly and realistically â€” no code now, just clear direction so you can structure it right.

ğŸ§© Step 1 â€” Understand what N25Q032A needs

It supports three modes of communication:

Mode	Lines Used	Typical Commands	Description
SPI (1-1-1)	1 MOSI, 1 MISO	0x03 (Read), 0x02 (Page Program), 0x05 (RDSR)	Classic serial mode
Dual (1-2-2)	1 MOSI, 2 data	0x3B (Fast Read Dual Output)	Command on 1 line, data on 2 lines
Quad (1-4-4)	1 MOSI, 4 data	0x6B (Fast Read Quad Output), 0x32 (Quad Page Program)	Command on 1 line, data on 4 lines

So your current QSPI master structure already supports these â€” you just need to adapt the transaction format.

ğŸ§© Step 2 â€” Transaction structure (for Read)

Each read operation (e.g., 0x6B Quad Fast Read) is sequenced like this:

Phase	Function	IO Lines Used	Description
1ï¸âƒ£	Command	1-bit (IO0)	Send opcode (0x6B)
2ï¸âƒ£	Address	1-bit (IO0)	24-bit address (MSB first)
3ï¸âƒ£	Dummy cycles	4-bit (all IOs)	Typically 8 dummy cycles (DUMMY_CYCLES = 8)
4ï¸âƒ£	Data	4-bit (all IOs)	Flash sends data (MISO equivalent on 4 lines)

You can now reuse your state machine (IDLE â†’ TRANSMISSION â†’ FINISH), but with sub-states for these four phases.

ğŸ§© Step 3 â€” Write (Page Program 0x32) structure
Phase	Function	IO Lines	Description
1ï¸âƒ£	Command	1-bit	0x32
2ï¸âƒ£	Address	1-bit	24-bit address
3ï¸âƒ£	Data	4-bit	Up to 256 bytes of data written
4ï¸âƒ£	Poll	1-bit	Poll 0x05 (Status Reg) until WIP = 0
ğŸ§© Step 4 â€” Signals to control

For this device, the main signals youâ€™ll need to integrate are:

Signal	Description
CS#	Active low, toggled between transactions
SCLK	Up to 108 MHz for Quad mode
IO0â€“IO3	Shared for input/output (your inout lines already handle this)
HOLD#, WP#	Can be tied high if not used
RESET#	Optional (active low)
ğŸ§© Step 5 â€” How to move from your current master to N25Q032A

You donâ€™t need to rewrite anything â€” just extend your FSM with small changes:

Add command_state, address_state, dummy_state, and data_state inside TRANSMISSION.

During Command/Address, keep sel_mode = 2â€™b00 (single-bit).

During Dummy/Data, switch to sel_mode = 2â€™b10 (quad).

Use your existing clock division and CPOL/CPHA logic unchanged.

Implement a ROM or memory input that holds command opcodes, dummy count, and mode bits per transaction type.

ğŸ§© Step 6 â€” Verification plan

To verify:

Create a behavioral N25Q032A model (Micron provides a Verilog model in the datasheet ZIP).

Connect it to your QSPI master and do a â€œread IDâ€ (0x9F) command first.

Expected output: 0x20 0xBA 0x16 for N25Q032A.

Then simulate Fast Read (0x6B) â€” verify dummy cycles and data alignment.

Finally simulate Page Program (0x32) + Read Back.


----

Perfect â€” now weâ€™re getting to the **fun part** ğŸ¯:
Integrating your **QSPI master** with an **actual flash device model** like **N25Q032A** (Micronâ€™s 32 Mbit Quad-SPI NOR Flash).

Letâ€™s break this down clearly so you know exactly what to wire, what to drive, and what to expect.

---

## ğŸ§© 1ï¸âƒ£ Know the Flash Device Interface

The **N25Q032A** has these key I/Os:

| Pin           | Function          | Direction | Description                          |
| :------------ | :---------------- | :-------- | :----------------------------------- |
| **S#**        | Chip Select       | Input     | Active low enable for command cycle  |
| **C**         | Clock             | Input     | Driven by your QSPI master (`sclk`)  |
| **DQ0 (IO0)** | Serial Data I/O 0 | I/O       | MISO/MOSI bit 0                      |
| **DQ1 (IO1)** | Serial Data I/O 1 | I/O       | MISO/MOSI bit 1                      |
| **DQ2 (IO2)** | Serial Data I/O 2 | I/O       | Used for quad + HOLD# in single mode |
| **DQ3 (IO3)** | Serial Data I/O 3 | I/O       | Used for quad + WP# in single mode   |
| **Vcc, GND**  | Power             | -         | Typical 2.7 â€“ 3.6 V operation        |

---

## ğŸ§  2ï¸âƒ£ The Protocol Flow

The flash operates in **transactions**, not just reads/writes.
Each operation follows a **command sequence** â€” hereâ€™s the typical **4-phase structure**:

| Phase               | Driven By                      | Description                                       |
| :------------------ | :----------------------------- | :------------------------------------------------ |
| **1. Command**      | Master (on IO0)                | An 8-bit opcode like `0x9F`, `0x03`, `0x6B`, etc. |
| **2. Address**      | Master                         | 24-bit address (for reads/writes)                 |
| **3. Dummy Cycles** | Master                         | N â€œdonâ€™t careâ€ clock cycles (used for latency)    |
| **4. Data Phase**   | Flash (read) or Master (write) | Data transfer in 1, 2, or 4-bit mode              |

---

## âš™ï¸ 3ï¸âƒ£ Top-Level Module Role

Your **Top module** sits above the QSPI master and handles these responsibilities:

1. **Drive command, address, data** to the `QSPI_Master`.
2. **Control the operation type** (`operation = 0/1` for read/write).
3. **Select mode** (`sel_mode = 2â€™b00 / 01 / 10` for SPI / Dual / Quad).
4. **Trigger transactions** in correct sequence.
5. Optionally, **handle state transitions** for Command â†’ Addr â†’ Dummy â†’ Data.

---

## ğŸ—ï¸ 4ï¸âƒ£ Top-Level Structure

Hereâ€™s what your top-level integration will look like (conceptually, not code):

```
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚           Top.v               â”‚
             â”‚  - Controls Flash Interface   â”‚
             â”‚  - Sends commands to QSPI     â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚        QSPI_Master.v          â”‚
             â”‚  - Generates clock, IO drive  â”‚
             â”‚  - Handles SPI/Dual/Quad modesâ”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
             â”‚        N25Q032A.v             â”‚
             â”‚  (Behavioral Flash Model)     â”‚
             â”‚  - Simulates NOR Flash timing â”‚
             â”‚  - Responds to commands       â”‚
             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš¡ï¸ 5ï¸âƒ£ Essential I/O Connections

| Top Signal    | Connects To           | Description                                     |
| ------------- | --------------------- | ----------------------------------------------- |
| `chip_select` | `S#`                  | Active low chip enable                          |
| `sclk`        | `C`                   | SPI clock                                       |
| `IO[3:0]`     | `DQ[3:0]`             | 4 data lines (bi-directional)                   |
| `sys_clk`     | Internal clock source | Drives divided QSPI clock                       |
| `nrst`        | Reset                 | Drives both master & flash reset (if supported) |

---

## ğŸ§­ 6ï¸âƒ£ Command Examples (for your FSM)

To interact with the flash, youâ€™ll send opcodes:

| Command                   | Opcode | Description                    | Mode   | Dummy Cycles |
| :------------------------ | :----- | :----------------------------- | :----- | :----------- |
| **Read ID**               | `0x9F` | Returns manufacturer/device ID | Single | 0            |
| **Read Data (Standard)**  | `0x03` | Read array data (slow)         | Single | 0            |
| **Fast Read (Dual)**      | `0x3B` | Faster, requires dummy cycles  | Dual   | 8            |
| **Fast Read Quad Output** | `0x6B` | Quad-mode read                 | Quad   | 8            |
| **Write Enable**          | `0x06` | Enables write                  | Single | 0            |
| **Page Program**          | `0x02` | Write 256-byte page            | Single | 0            |
| **Sector Erase (4 KB)**   | `0x20` | Erases one 4 KB sector         | Single | 0            |

---

## ğŸ” 7ï¸âƒ£ FSM Outline for the Top

Your top FSM could look like this:

```text
RESET
  â†“
IDLE
  â†“ (trigger)
SEND_CMD (send opcode via QSPI_Master)
  â†“
SEND_ADDR (send address if needed)
  â†“
DUMMY (generate dummy cycles)
  â†“
DATA_PHASE
  â†“
FINISH (chip_select â†’ 1, transaction_done)
```

You can reuse your `QSPI_Master` for each phase â€” just change:

* `wr_data` for each byte you send.
* `operation` (0 or 1).
* `trigger_transmission` (pulse).
* `sel_mode` depending on mode.

---

## ğŸ’¾ 8ï¸âƒ£ Behavioral Model for Flash (Simulation)

You can use Micronâ€™s **official Verilog model** for N25Q032A.
Itâ€™s available publicly at:
ğŸ”— [Micron Verilog Model Download Page](https://www.micron.com/products/nor-flash/serial-nor-flash)

Youâ€™ll find:

```
N25Q032A13E_VG12M_TB.v
N25Q032A13E_VG12M.v
```

You instantiate it like:

```verilog
N25Q032A flash_inst (
    .S( chip_select ),
    .C( sclk ),
    .DQ0( IO[0] ),
    .DQ1( IO[1] ),
    .DQ2( IO[2] ),
    .DQ3( IO[3] ),
    .Vcc(1'b1),
    .Vpp(1'b1),
    .HOLD_DQ3(1'b1),
    .RESET_DQ3(1'b1)
);
```

---

## ğŸ§ª 9ï¸âƒ£ Minimal Test Plan

To test integration before full flash commands:

1. **Read ID (0x9F)** â€” simplest test.
   Expect 3 bytes back (manufacturer + memory type + capacity).
2. **Fast Read (0x6B)** â€” test dummy cycles + quad transfer.
3. **Write Enable (0x06)** â€” confirm WEL bit set.
4. **Read Status (0x05)** â€” confirm status byte changes.

---

## âœ… 10ï¸âƒ£ Summary of What to Do Next

| Step | Action                                                                    |
| ---- | ------------------------------------------------------------------------- |
| 1    | Download and add the `N25Q032A.v` model to your `/src/flash` folder.      |
| 2    | Write `QSPI_Top.v` to instantiate both `QSPI_Master` and the flash model. |
| 3    | Add simple FSM: Send `0x9F` â†’ read 3 bytes â†’ print result.                |
| 4    | Verify waveform: SCLK, IOs, chip_select.                                  |
| 5    | Once working, add dummy cycles + dual/quad modes.                         |

---

Would you like me to give you a **step-by-step FSM outline** (signals, byte order, and control timing) for the **0x9F â€œRead IDâ€ command** next?
Thatâ€™s the best first real flash test â€” small and perfectly verifiable.
